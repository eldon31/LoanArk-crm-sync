name: Sync HubSpot Contacts
on:
  schedule:
    - cron: '0 */12 * * *'  # Every 12 hours (midnight and noon)

  workflow_dispatch:  # Allow manual trigger from GitHub UI

jobs:
  sync:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install Dependencies
        run: npm install @supabase/supabase-js node-fetch

      - name: Sync HubSpot Contacts
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          HUBSPOT_API_KEY: ${{ secrets.HUBSPOT_API_KEY }}
        run: |
          node << 'SCRIPT'
          const { createClient } = require('@supabase/supabase-js');
          const fetch = require('node-fetch');

          const supabase = createClient(
            process.env.SUPABASE_URL,
            process.env.SUPABASE_SERVICE_KEY
          );

          async function syncContacts() {
            console.log('üöÄ Starting HubSpot sync...');

            // Create sync job
            const { data: job, error: jobError } = await supabase
              .from('sync_jobs')
              .insert({
                type: 'scheduled',
                status: 'processing',
                started_at: new Date().toISOString(),
                metadata: {
                  source: 'github_action',
                  schedule: '12_hour',
                  timestamp: new Date().toISOString()
                }
              })
              .select()
              .single();

            if (jobError) {
              console.error('Failed to create sync job:', jobError);
              process.exit(1);
            }

            console.log('üìã Sync job created:', job.id);

            try {
              // Fetch all contacts from HubSpot
              const contacts = await fetchAllHubSpotContacts();
              console.log(`‚úÖ Fetched ${contacts.length} contacts from HubSpot`);

              // Track metrics
              let processed = 0, created = 0, updated = 0, failed = 0;
              const batchSize = 100;

              // Process in batches for better performance
              for (let i = 0; i < contacts.length; i += batchSize) {
                const batch = contacts.slice(i, i + batchSize);
                console.log(`Processing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(contacts.length/batchSize)}...`);

                // Map HubSpot properties to Supabase columns
                const mappedContacts = batch.map(contact => ({
                  hs_object_id: String(contact.id),
                  email: contact.properties.email || null,
                  email_verification_status: contact.properties.email_verification_status || null,
                  firstname: contact.properties.firstname || null,
                  lastname: contact.properties.lastname || null,
                  phone: contact.properties.phone || null,
                  mobilephone: contact.properties.mobilephone || null,
                  client_type_vip_status: contact.properties.client_type_vip_status || null,
                  client_type_prospects: contact.properties.client_type_prospects || null,
                  address: contact.properties.address || null,
                  city: contact.properties.city || null,
                  state: contact.properties.state || null,
                  zip: contact.properties.zip || null,
                  createdate: contact.properties.createdate ? new Date(contact.properties.createdate) : null,
                  lastmodifieddate: contact.properties.lastmodifieddate ? new Date(contact.properties.lastmodifieddate) : null,
                  sync_source: 'hubspot',
                  updated_at: new Date().toISOString()
                }));

                // Upsert to Supabase
                const { data: upsertData, error: upsertError } = await supabase
                  .from('contacts')
                  .upsert(mappedContacts, {
                    onConflict: 'hs_object_id',
                    ignoreDuplicates: false
                  })
                  .select();

                if (upsertError) {
                  console.error('Batch upsert error:', upsertError);
                  failed += batch.length;

                  // Log error for this batch
                  await supabase.from('sync_logs').insert({
                    sync_job_id: job.id,
                    action: 'error',
                    status: 'failed',
                    error_message: upsertError.message,
                    metadata: { batch_start: i, batch_end: i + batch.length }
                  });
                } else {
                  processed += batch.length;

                  // Count created vs updated (simplified - you can enhance this)
                  if (upsertData && upsertData.length > 0) {
                    updated += upsertData.length;
                  }
                }
              }

              // Update job as completed
              await supabase
                .from('sync_jobs')
                .update({
                  status: 'completed',
                  completed_at: new Date().toISOString(),
                  records_processed: processed,
                  records_created: created,
                  records_updated: updated,
                  records_failed: failed,
                  metadata: {
                    ...job.metadata,
                    completion_details: {
                      total_fetched: contacts.length,
                      batch_size: batchSize,
                      success_rate: ((processed / contacts.length) * 100).toFixed(2) + '%'
                    }
                  }
                })
                .eq('id', job.id);

              console.log(`
‚úÖ SYNC COMPLETED SUCCESSFULLY
üìä Statistics:
   - Total Processed: ${processed}
   - Updated: ${updated}
   - Failed: ${failed}
   - Success Rate: ${((processed / contacts.length) * 100).toFixed(2)}%
              `);

            } catch (error) {
              console.error('‚ùå Sync failed:', error);

              // Update job as failed
              await supabase
                .from('sync_jobs')
                .update({
                  status: 'failed',
                  completed_at: new Date().toISOString(),
                  error_message: error.message
                })
                .eq('id', job.id);

              // Log the error
              await supabase.from('sync_logs').insert({
                sync_job_id: job.id,
                action: 'error',
                status: 'failed',
                error_message: error.message,
                metadata: { error_stack: error.stack }
              });

              process.exit(1);
            }
          }

          async function fetchAllHubSpotContacts() {
            const allContacts = [];
            let after = undefined;

            // Define all properties we need from HubSpot
            const properties = [
              'email',
              'email_verification_status',
              'firstname',
              'lastname',
              'phone',
              'mobilephone',
              'client_type_vip_status',
              'client_type_prospects',
              'address',
              'city',
              'state',
              'zip',
              'createdate',
              'lastmodifieddate'
            ];

            do {
              const url = new URL('<https://api.hubapi.com/crm/v3/objects/contacts>');
              url.searchParams.append('limit', '100');
              url.searchParams.append('properties', properties.join(','));

              if (after) {
                url.searchParams.append('after', after);
              }

              console.log(`Fetching page ${after ? 'after ' + after : '1'}...`);

              const response = await fetch(url.toString(), {
                headers: {
                  'Authorization': `Bearer ${process.env.HUBSPOT_API_KEY}`,
                  'Content-Type': 'application/json'
                }
              });

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HubSpot API error: ${response.status} - ${errorText}`);
              }

              const data = await response.json();
              allContacts.push(...data.results);

              after = data.paging?.next?.after;

              // Small delay to respect rate limits (100 requests per 10 seconds)
              await new Promise(resolve => setTimeout(resolve, 150));

            } while (after);

            return allContacts;
          }

          // Also check for pending manual sync jobs
          async function processPendingJobs() {
            const { data: pendingJobs } = await supabase
              .from('sync_jobs')
              .select('*')
              .eq('status', 'pending')
              .order('created_at', { ascending: true });

            if (pendingJobs && pendingJobs.length > 0) {
              console.log(`Found ${pendingJobs.length} pending manual sync jobs. Processing...`);

              for (const pendingJob of pendingJobs) {
                await supabase
                  .from('sync_jobs')
                  .update({
                    status: 'processing',
                    started_at: new Date().toISOString()
                  })
                  .eq('id', pendingJob.id);

                // Run sync for this job
                await syncContacts();
              }
            }
          }

          // Run the sync
          syncContacts()
            .then(() => processPendingJobs())
            .then(() => {
              console.log('‚úÖ All sync operations completed');
              process.exit(0);
            })
            .catch((error) => {
              console.error('Fatal error:', error);
              process.exit(1);
            });
          SCRIPT

      - name: Send notification on failure
        if: failure()
        run: |
          echo "‚ùå Sync failed! Check the logs for details."
          # You can add email/Slack notifications here if needed
